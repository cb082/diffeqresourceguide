<html>

<head>
	
	<meta charset="UTF-8">
	<meta name="author" content="Todd Schmid">
	
	<!-- Renders latex formulas -->
	<script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
	<script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    
	<!-- Renders tikz figures mid page -->
    <link rel="stylesheet" type="text/css" href="https://tikzjax.com/v1/fonts.css">
    <script src="https://tikzjax.com/v1/tikzjax.js"></script>
	
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	
	<link rel="stylesheet" href="../../../styles.css" />
	<link rel="stylesheet" href="../../course_styles.css" />
	<link rel="icon" href="../../../squidab.png" />
	
	<!-- * Customize for each course * -->
	<title>CSCI 341 Theory of Computation</title>
	<meta name="description" content="Course pages for CSCI 341.">
	<meta name="keywords" content="bucknell,theory,computer,science,schmid,csci341">
	<!-- ***************************** -->
</head>

<body>

<div id="content">

<!-- Header Section -->
<div id="course_head" style="text-align: left;">
	<h1 style="margin-bottom: 0; text-align: left;">CSCI 341 Theory of Computation</h1>
	<i>Fall 2025, with <a href="../../../teaching.html">Schmid</a></i>
	<div id="links">
		<!-- * Customize for each course * -->
		<a href="csci341_syllabus.html"><span class="link">Syllabus</span></a>
		<a href="csci341_notes.html"><span class="link">Notes</span></a>
		<a href="csci341_resources.html"><span class="link">Resources</span></a>

		<!-- Make sure to update with correct gradescope link-->
		<a href= 
			"http://www.gradescope.com" 
			target="_blank"><span class="link">Gradescope</span></a>
		<!-- ***************************** -->
	</div>
</div>



<div id="stuff">


<!-- BEGINNING OF BODY -->
<h2>Table of Contents</h2>

<div id="contents">
	<ul style="list-style-type: none;">
		<li><a href="csci341_0_what_is_computation.html">What is <i>Computation</i>?</a></li>
		<li><b>Part 1.</b> Memoryless State Machines
			<ol>
				<li><a href="csci341_1_0_games_and_state_diagrams.html">Puzzle games, solutions, and state diagrams</a></li>

				<li><a href="csci341_1_1_automata.html">Automata</a></li>

				<li><a href="">Describing accepted languages</a></li>
				<!--
					- Words from an alphabet
					- The empty set, the empty word
					- Languages from an alphabet
					- Describing the space of accepted moves 
						• set comprehension
						• union, intersection
						• concatenation
						• the Kleene star 	
				-->

				<li><a href="">Finite and infinite deterministic automata</a></li>
				<!-- 
					- Examples of Deterministic Finite Automata (DFAs)
						• Example. The integers modulo 3, Z/3Z = {0, 1, 2}, with alphabet A = {(x + 1) % 3, (x + 2) % 3}
						• Examples. Mazes, parity relations, and sokoban games
					- Infinite examples of deterministic automata
						• Example. The integers Z, with the shift alphabet A = {-1, +1} and even numbers accepting
							>> Language accepted by 0?
						• Example. The deterministic automaton of all languages from an alphabet
					- Reachability and local finiteness
					- Languages as states
						• The Brzozowski derivative
						• Acceptance and the empty word property
						• Languages accept themselves (so every language is accepted by some state in some deterministic automaton!)
					- DFA languages
				-->	

				<li><a href="">Combining Automata I: Meets, Joins, and Complementation</a></li>
				<!-- 
					- Warming up: disjoint union
					- Complementation
					- The product construction for deterministic transition systems
						• product-meet = intersection
						• product-join = union
					- An intuitive construction: Glueing? (feeds into nondeterminism!)
				-->					
				
				<li><a href="">Introducing Nondeterminism</a></li>
				<!--
					- Making sense of glueing
					- A function is a kind of relation
					- Nondeterminism = moving from functions to relations
						• Relations as functions X -> P(X)
					- Three interpretations:
						• What words *could* an unpredictable machine accept?	
						• A working machine with different but indistinguishable labels
						• Teamwork (or cloning yourself)
					- Nondeterministic Finite Autommata
						• X = state space
						• A = alphabet
						• \delta : A x X -> P(X)
						• \alpha : X -> 2
					- NFA languages
				-->

				<li><a href="">DFAs and NFAs</a></li>
				<!-- 
					- Translating a DFA into an NFA
						• Every DFA language is an NFA language
					- But NFAs are smaller in general
					- Overturning power with determinization
						• Every NFA language is a DFA language
				-->

				<li><a href="">Silent transitions &#129323;</a></li>
				<!--
					- Skiping a beat: there are unobservable transitions
					- Nondeterministic Finite Automata with silent transitions (NFA_{\e})
						• X = state space
						• A = alphabet
						• \delta : (A u \epsilon) x X -> P(X)
						• \alpha : X -> 2
					- Every NFA is an NFA_{\e}
					- Language accepted by a state in an NFA_{\e}
				-->

				<li><a href="">Killing epsilons with a dagger</a></li>
				<!--
					- The dagger construction
					- Every NFA_{\e} language is an NFA language
					- DFA languages = NFA languages = NFA_{\e} languages
						• Call all of these *finite acceptor languages*, or FA languages
				-->

				<li><a href="">Combining Automata II: sequential composition and iteration</a></li>
				<!--
					- The tent construction
						• Union
					- The suspention construction (placing a state on either end)
					- Using silent transitions to connect accepting states to starting states
						• Sequential Composition
						• Iteration			
				-->

				<li><a href="">The Pumping Lemma</a></li>
				<!--
					- Weakest version
					- A little less weak
					- Strongest version
					- Examples of non-DFA languages
						• a^nb^n
						• Palindromes
						• Adding up to 0
						• Balanced brackets
				-->
				
			</ol>
		</li> <!-- ****** End of Part 1 -->



		<li><a href="csci341_1_introduction.html"><b>Part 2.</b> Introduction to Formal Language Theory</a>
		<ol>

				<li><a href="csci341_1_introduction.html">Regular Expressions</a></li>
				<!--
					- Recursive definition of regular expressions
					- Language semantics of regular expressions: regular languages
					- Language equivalence of regular expressions
						• Some useful (basic) identities
						• The empty word property and Arden's rule
				-->

				<li><a href="csci341_1_introduction.html">Pick your weapon: Antimirov derivatives or Thompson's construction</a></li>
				<!--
					- Every regular expression denotes an NFA
						• Antimirov's derivative construction: using regular expressions as states
							>> Ant(r) is finite, with O(n) states
							>> L(Ant(r), r) = L(r)
						• Thompson's construction: recursively building an NFA_{\e}
							>> Tho(r) is finite, also O(n) states
							>> L(Tho(r), r) = L(r)
					- Corollary: Every regular language is a FA language
				-->

				<li><a href="csci341_1_introduction.html">Kleene's Theorem, or Gaussian Elimination for NFAs</a></li>
				<!--
					- Left-affine systems of equations over an alphabet A
						• Guardedness
					- A language-based solution to a left-affine system
					- Guarded left-affine systems have unique solutions
						• Gaussian Elimination for left-affine systems
						• Repeated use of Arden's rule and the "useful identities" from before
					- Language acceptance and NFAs as guarded left-affine systems
					- Corollary: every FA language is a regular language
					- Kleene's Theorem: FA languages = Regular languages
				-->

				<li><a href="csci341_1_introduction.html">Beyond Regularity: Non-affine systems</a></li>
				<!--
					- Going from left-affine systems of equations to "polynomial" systems of equations goes beyond regular/FA languages
						• a^nb^n
						• Palindromes
						• Adding up to 0
						• Balanced brackets
					- Solving polynomial systems by way of derivations
				-->

				<li><a href="csci341_1_introduction.html">Context-free Grammars</a></li>
				<!--
					- definition of a context-free grammar (CFG)
						• N = nonterminal variables
						• A = terminal constants
						• \delta : N -> (A u N)* = derivation rules
					- Complete derivations
					- Context-free languages
				-->

				<li><a href="csci341_1_introduction.html">Designing Context-free Grammars</a></li>
				<!--
					
				-->
				
				<li><a href="csci341_1_introduction.html">The Chomsky Hierarchy</a></li>
				<!--
					- 
				-->

			</ol>
		</li> <!-- ****** End of Part 3 -->


		<li><a href="csci341_1_introduction.html"><b>Part 3.</b> Machines with Memory</a>
			<ol>
				<li><a href="csci341_1_introduction.html">Solving Problems with Stacks</a></li>
				<!--
					- Algorithms that use a stack to decide...
						• a^nb^n
						• Palindromes
						• Adding up to 0
						• Balanced brackets
				-->

				<li><a href="csci341_1_introduction.html">Push-Down Automata</a></li>
				<!--
					- PDA = NFA_{\e} + Stack
						• X = state space
						• A = input alphabet
						• S = stack alphabet
						• \delta : ({\e} u A) x X -> P(({\e} u ↿S) x ({\e} u ⇃S) x X)
						• Balanced brackets
					- PDA languages
					- PDAs are infinite NFA_{\e}s
					- PDAs =/= DFA + Stack
				-->

				<li><a href="csci341_1_introduction.html">Designing Push-Down Automata</a></li>
				<!--
					- 
				-->

				<li><a href="csci341_1_introduction.html">CFGs from PDAs</a></li>
				<!--
					- Every Context-free language is PDA
				-->

				<li><a href="csci341_1_introduction.html">PDAs from CFGs</a></li>
				<!--
					- Every PDA language is Context-free
					- PDA Languages = Context-free Languages
				-->

				<li><a href="csci341_1_introduction.html">Beyond the Stack: Tapes</a></li>
				<!--
					- The tape head
					- Reading, writing, and moving
					- Programming a tape head
					- Solving problems with a tape head
				-->

				<li><a href="csci341_1_introduction.html">Turing Machines</a></li>
				<!--
					- Input string goes on a tape
					- TM = DFA + Tape
						• X = state space
						• A = input alphabet
						• T = tape alphabet
						• \delta : ({\e} u A) x X -> ({\e, >, <} u {∨} x T) x (2 u X)
					- The languages accepted and rejected by a TM
					- Decidable languages
				-->

				<li><a href="csci341_1_introduction.html">Designing Turing Machines</a></li>
				<!--
					- 2s complement
					- reversing text
					- perfect squares
					- Simulating a DFA
					- Simulating a PDA
				-->

				<li><a href="csci341_1_introduction.html">Recognizable and co-Recognizable Languages</a></li>
				<!--
					- Halting states
					- Enumerable languages
				-->

				<li><a href="csci341_1_introduction.html">Variants of Turing Machines</a></li>
				<!--
					- TM equivalents:
						• Multi-tape TMs
						• Nondeterministic TMs
						• One-sided TMs
						• An assembly-like language for tape heads
						• WHILE programs and flow charts
					- The Church-Turing Thesis
						• Turing-hard = can simulate a TM
						• Turing-complete = TM can simulate you
					    • Thesis: Turing-hard = Turing-complete
						• A mathematical definition of the word "algorithm"
				-->

			</ol>
		</li><!-- ****** End of Part 3 -->


		<li><a href="csci341_1_introduction.html"><b>Part 4.</b> (Un)Decidability</a>
		<ol>
				<li><a href="csci341_1_introduction.html">Encodings and Universal Turing Machines</a></li>
				<!--
					- Turing machines as encodable objects
					- Running a TM within a TM
				-->

				<li><a href="csci341_1_introduction.html">The Halting Problem</a></li>
				<!--
					- Turing's diagonalization argument
					- Recognizable but not co-recognizable
				-->

				<li><a href="csci341_1_introduction.html">Reductions</a></li>
				<!--
					- Language inhabitation
					- Language equivalence
					- A language neither recognizable or co-recognizable
				-->

				<li><a href="csci341_1_introduction.html">Post's correspondence theorem</a></li>
				<!--
					- 
				-->

			</ol>
		</li> <!-- ****** End of Part 4 -->

		<li><a href="csci341_1_introduction.html">Concluding Remarks and Open Problems</a></li>

	</ul> <!-- ***** End of Table of Contents -->
</div>


<!-- END OF BODY -->
    <div style="height: 50px;border-top: 1px solid rgb(131, 131, 131);margin-top: 50px; padding: 20px; text-align: right;">
        <a href=""><span class="link">Top</span></a>
    </div>
</div>
</div>
</body>


</html>