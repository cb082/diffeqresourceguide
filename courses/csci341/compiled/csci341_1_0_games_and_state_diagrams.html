<html>

<head>
	
	<meta charset="UTF-8">
	<meta name="author" content="Todd Schmid">
	
	<!-- Renders latex formulas -->
	<script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
	<script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    
	<!-- Renders tikz figures mid page -->
    <link rel="stylesheet" type="text/css" href="https://tikzjax.com/v1/fonts.css">
    <script src="https://tikzjax.com/v1/tikzjax.js"></script>
	
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	
	<link rel="stylesheet" href="../../../styles.css" />
	<link rel="stylesheet" href="../../course_styles.css" />
	<link rel="icon" href="../../../squidab.png" />
	
	<!-- * Customize for each course * -->
	<title>CSCI 341 Theory of Computation</title>
	<meta name="description" content="Course pages for CSCI 341.">
	<meta name="keywords" content="bucknell,theory,computer,science,schmid,csci341">
	<!-- ***************************** -->
</head>

<body>

<div id="content">

<!-- Header Section -->
<div id="course_head" style="text-align: left;">
	<h1 style="margin-bottom: 0; text-align: left;">CSCI 341 Theory of Computation</h1>
	<i>Fall 2025, with <a href="../../../teaching.html">Schmid</a></i>
	<div id="links">
		<!-- * Customize for each course * -->
		<a href="csci341_index.html"><span class="link">Index</span></a>
		<a href="csci341_syllabus.html"><span class="link">Syllabus</span></a>
		<a href="csci341_notes.html"><span class="link">Notes</span></a>
		<a href="csci341_resources.html"><span class="link">Resources</span></a>

		<!-- Make sure to update with correct gradescope link-->
		<a href= 
			"http://www.gradescope.com" 
			target="_blank"><span class="link">Gradescope</span></a>
		<!-- ***************************** -->
	</div>
</div>



<div id="stuff">


<!-- BEGINNING OF BODY -->
<h1>Games, State Diagrams, and Winning</h1>

<p>
    If you haven't noticed this yet in your math-based courses, one of the quirks of an abstract mathematical definition is that it can apply to really unexpected examples.
    Part of the fun of theoretical computer science is that those abstract mathematical definitions are often not too hard to reverse engineer <i>from</i> the unexpected examples. 
    Case in point, let's play some puzzle games, shall we?
</p>

<h2>Some 2-D Puzzle Games</h2>

<h3>Directional Mazes</h3>
<div class="definition">
    <b>Definition (Directional Maze)</b>
    A <i>directional maze</i> \(M\) consists the following components:
    <ul>
        <li>An \(n\times m\) grid \(G\) of <i>positions</i>, where \(n\) and \(m\) are whole numbers</li>
        <li>A set of <i>legal positions</i> \(L \subseteq G\)</li>
        <li>Two postions called \(S\)tart and \(E\)nd</li>
        <li>A set of <i>legal moves</i> \(A \subseteq \{\Uparrow, \Downarrow, \Rightarrow, \Leftarrow\}\)</li>
        <li>A spelunker, \(C\)oby, that inhabits any legal position</li>
    </ul>
    You play a directional maze by applying legal moves to change the position of \(C\) from any legal position to any other legal position.
    A <i>solution</i> to a directional maze is a sequence of legal moves that takes \(C\) from \(S\) to \(E\).
</div>
<p>
    Here is an example:
</p>
<div class="figure" id="thesmileymaze">
    <img src="../imgs/smilemaze.png" />
    The Smiley Maze
</div>
<p>
    The directional maze above consists of a \(10\times 10\) grid of positions. 
    The set of legal positions \(L\) is the set of white or beige positions, and in this case the only legal moves are \(A = \{\Rightarrow, \Uparrow\}\).
</p>
<div class="exercise">
    <b>Exercise (Smiley Maze)</b>
    <ol>
        <li>Does the sequence \(\Uparrow\Uparrow\Uparrow\Rightarrow\Uparrow\) solve the Smiley Maze?</li>
        <li>Find a solution to the Smiley Maze, in the form of a <i>sequence of legal moves from \(A\)</i>.</li>
        <li>How many solutions are there?</li>
        <li>Change one position on the grid from illegal to legal such that there is exactly one additional solution after the change.</li>
    </ol>
    If you're not feeling <i>over it</i> yet, repeat this exercise a second time for the Spotted Maze below.
</div>
<div class="figure" id="thespottedmaze">
    <img src="../imgs/dirmaze1.png" />
    The Spotted Maze. The \(S\)tart is in the bottom-left corner and the \(E\)nd is in the top right.
</div>
<p>
    So, we have already seen that a <i>solution</i> is a sequence of legal moves that brings \(C\)oby from the \(S\)tart to the \(E\)nd of the maze.
    We have already seen that more than one solution can exist for a particular maze. 
</p>
<div class="definition">
    Given a directional maze \(M = (G, L, S, E, A, C)\), the <i>solution space</i> of \(M\) is set of all sequences of legal moves from \(A\) that bring \(C\) from \(S\) to \(E\).
    The solution space is written \(\mathcal S(M)\).
</div>
<div class="exercise">
    <b>Exercise (Sunshine)</b>
    Find a directional maze \(M\) whose solution space is exactly 
    \[
    \mathcal S(M) = \{\Uparrow\Uparrow\Uparrow\Rightarrow\Rightarrow\Uparrow, \Uparrow\Rightarrow\Rightarrow\Uparrow\Uparrow\Uparrow\}
    \]
    (There are exactly two solutions in \(\mathcal S(M)\).) 
    If you haven't already, try to find the smallest one, and write down a proof that it is indeed the smallest.
</div>
<div class="exercise">
    <b>Exercise (No Upper Bounds)</b>
    Find a directional maze that has an <i>infinite</i> solution space (again, try to find the smallest one).
</div>
<div class="problem">
    <b>Problem (Always an Upper Bound)</b>
    Let \(M = (G, L, S, E, A, C)\) be a directional maze with the set of legal moves \(A = \{\Uparrow, \Rightarrow\}\).
    Prove that \(\mathcal S(M)\) is finite (there are only finitely many elements) by calculating an upper bound on the number of all possible legal paths through an \(n\times m\) directional maze.
</div>
<p>
    Depending on where 
</p>

<h3>Sokoban</h2>

<h2>State Space</h2>
<!-- Decision problems versus computation problems:
A computational problem asks for an input/output procedure (a function) that adheres to some specification. A solution to a decision problem is such a procedure.
A decision problem is a computation problem where the output is True or False (typically represented as 1 or 0).
Decision problems are the central focus of this course.
Why we study decision problems in theory of computation:
Many computation problems can be translated into decision problems
Decision problems are simple to describe, and in practice solutions typically achieve more general computational tasks along the way.
Our goal will be to discover the limitations of different forms of computation, and these limitations are already visible for decision problems. -->



<!-- END OF BODY -->
</div>
</div>
</body>


</html>