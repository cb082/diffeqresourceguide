<!-- THIS IS A COMPILED FILE 
 Compiled on 2025-09-04 -->



































































































<html>

<head>
	
	<meta charset="UTF-8">
	<meta name="author" content="Todd Schmid">
	
	<!-- Renders latex formulas -->
	<script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
	<script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    
	<!-- Renders tikz figures mid page -->
    <link rel="stylesheet" type="text/css" href="https://tikzjax.com/v1/fonts.css">
    <script src="https://tikzjax.com/v1/tikzjax.js"></script>
	
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	
	<link rel="stylesheet" href="../../../styles.css" />
	<link rel="stylesheet" href="../../course_styles.css" />
	<link rel="icon" href="../../../squidab.png" />
	
	<!-- * Customize for each course * -->
	<title>CSCI 341 Theory of Computation</title>
	<meta name="description" content="Course pages for CSCI 341.">
	<meta name="keywords" content="bucknell,theory,computer,science,schmid,csci341">
	<!-- ***************************** -->
</head>

<body>

<div id="content">

<!-- Header Section -->
<div id="course_head" style="text-align: left;">
	<h1 style="margin-bottom: 0; text-align: left;">CSCI 341 Theory of Computation</h1>
	<i>Fall 2025, with <a href="../../../teaching.html">Schmid</a></i>
	<div id="links">
		<!-- * Customize for each course * -->
		<a href="csci341_index.html"><span class="link">Syllabus</span></a>
		<a href="csci341_notes.html"><span class="link">Notes</span></a>
		<a href="csci341_resources.html"><span class="link">Resources</span></a>
		<a href= "csci341_assignments.html"><span class="link">Assignments</span></a>
		<!-- ***************************** -->
	</div>
</div>



<div id="stuff">


<!-- BEGINNING OF BODY -->
<h1>Antimirov Derivatives</h1>

<p>
    We are currently working toward using regular expressions as a coding language for automata, specifically finite automata.
    Today, we are going to show that every regular expression represents a state in a finite automaton.  
    We are going to start by defining an infinite automaton, called the <i>Antimirov automaton</i> \(\mathcal A_{Ant}\), whose states are regular expressions and such that \(\mathcal L(\mathcal A_{Ant}, r) = \mathcal L(r)\) for every regular expression \(r \in \mathit{RExp}\).
    This is analogous to the Brzozowski automaton, whose states were languages.
    Except in this case, the states are expressions!
</p>

<h2>Antimirov Derivatives</h2>

<p>
    When we built the Brzozowski automaton, we needed to define what was called the <i>Brzozowski derivative</i> of a language, \(a^{-1}L\) for each \(a \in A\) and \(L \in 2^{A^*}\).
    To define the Antimirov automaton, we have to do something similar---we are going to define a notion of derivative for regular expressions.
    However, there is an important difference between the Brzozowski automaton and the Antimirov automaton: the Brzozowski automaton is total and deterministic, but the Antimirov automaton is neither. 
    In other words, a regular expression can have <i>multiple</i> Antimirov derivatives.
</p>

<p>
    Here is the formal definition:
</p>

<div class="definition">
    <b>(Antimirov Automaton)</b>
    Let \(A\) be an alphabet of input symbols.
    The <i>Antimirov automaton</i> is the automaton \(\mathcal A_{Ant} = (\mathit{RExp}, A, \delta, F)\), where \(\delta\) and \(F\) are defined recursively by the following rules:

    <p>
        Starting with \(F\), we define 
        <ol type="i">
            <li>\(\emptyset \notin F\) and \(a \notin F\) for any \(a \in A\)</li>
            <li>\(\varepsilon \in F\)</li>
            <li>for any regular expression \(r\), we have \(r^* \in F\)</li>
        </ol>
        and recursively, for regular expressions \(r_1,r_2 \in \mathit{RExp}\):
        <ol start=4 type="i">
            <li>\((r_1 + r_2) \in F\) if and only if \(r_1 \in F\) or \(r_2 \in F\)</li>
            <li>\((r_1 \cdot r_2) \in F\) if and only if \(r_1 \in F\) and \(r_2 \in F\)</li>
        </ol>
    </p>
    <p>
        Now let's define \(\delta\).
        We are going to use the reading notation from before to define \(\delta\), where we wrote \(\delta(x, w)\) to denote the set of states that are active after reading a word \(w\) from \(x\).
        In the Antimirov automaton, states are regular expressions, so in each of the equations below describing \(\delta\), you will see \(\delta(r, a)\).
        Here, \(r\) is a regular expression and \(a\) is a letter.
    </p>
    <p>
        Let's get into it:
        for any \(a \in A\), we define
        <ol type="A">
            <li>\(\delta(\emptyset, a) = \{\}\)</li>
            <li>\(\delta(\varepsilon, a) = \{\}\)</li>
            <li>\(\delta(a, a) = \{\varepsilon\}\)</li>
            <li>\(\delta(a, b) = \{\}\) where \(b \in A\) and \(b \neq a\)</li>
        </ol>
        and recursively, for any regular expressions \(r, r_1, r_2 \in \mathit{RExp}\):
        <ol start="5" type="A">
            <li>\(\delta(r_1 + r_2, a) = \delta(r_1, a) \cup \delta(r_2, a)\)</li>
            <li>\(\delta(r_1 \cdot r_2, a) = \{s \cdot r_2 \mid s \in \delta(r_1, a)\} \cup \{s \mid r_1 \in F \text{ and } s \in \delta(r_2, a)\}\)</li>
            <li>\(\delta(r^*, a) = \{s \cdot r^* \mid s \in \delta(r, a)\}\)</li>
        </ol>
        The elements of \(\delta(r, a)\) are called the <i>Antimirov \(a\)-derivatives of \(r\)</i>.
    </p>
</div>

<p>
    To reiterate: states of \(\mathcal A_{Ant}\) are regular expressions.
    The transitions of \(\mathcal A_{Ant}\) are therefore transitions <i>between regular expressions</i>.
    And furthermore, like the Brzozowski automaton, transitions are given by derivatives. 
    Except, in this case, derivatives look a bit different: regular expressions can have multiple derivatives. 
    Before we get to the multiple-derivatives situation, let's look at a small example.
</p>

<div class="example">
    <b>(First Antimirov Derivatives)</b>
    Let's start with the regular expression \(a + b\).
    By E above, \(\delta(a + b, a) = \delta(a, a) \cup \delta(b, a)\).
    By C above, \(\delta(a, a) = \{\varepsilon\}\) and \(\delta(b, a) = \{\}\).
    This tells us that 
    \[
        \delta(a + b, a) = \delta(a, a) \cup \delta(b, a) = \{\varepsilon\} \cup \{\} = \{\varepsilon\}
    \]
    So that we would see in the Antimirov automaton that \(a + b \xrightarrow{a} \varepsilon\).
</div>

<div class="exercise">
    <b>(There's the b)</b>
    Find the Antimirov \(b\)-derivatives of \(a + b\). 
    That is, compute 
    \[
        \delta(a + b, b) = \text{?}
    \]
    in the Antimirov automaton.
</div>

<div class="example">
    Now let's take a look at \(a \cdot b\). 
    From F, 
    \[
        \delta(a\cdot b, a) = \{s \cdot b \mid s \in \delta(a, a)\} \cup \{s \mid a \in F \text{ and } s \in \delta(b, a)\}
    \]
    We know from i that \(a \notin F\), so \(\{s \mid a \in F \text{ and } s \in \delta(b, a)\} = \{\}\).
    Moreover, \(\delta(a, a) = \{\varepsilon\}\), so 
    \[\begin{aligned}
        \delta(a\cdot b, a) 
        &= \{s \cdot b \mid s \in \delta(a, a)\} \cup \{s \mid a \in F \text{ and } s \in \delta(b, a)\} && \text{(F)}\\
        &= \{s \cdot b \mid s \in \delta(a, a)\} \cup \{\} && \text{(i)}\\
        &= \{\varepsilon \cdot b\} \cup \{\} && \text{(C)}\\
        &= \{\varepsilon \cdot b\}
    \end{aligned}\]
    So, in the Antimirov automaton, you would see the transition \(a\cdot b \xrightarrow{a} \varepsilon \cdot b\).
</div>

<div class="exercise">
    <b>(Now where's the b gone?)</b>
    What is \(\delta(a \cdot b, b)\)?
</div>

<div class="example">
    <b>(Slightly More Complex Derivatives)</b>
    Let's do a slightly more complicated one. 
    If we plug-and-chug, derivatives can always be computed by unfolding the definitions, so let's do that for a more complicated example:
    given \(a,b,c \in A\), let's calculate the Antimirov \(a\)-derivatives of \(a\cdot b + a\cdot b\cdot c + \varepsilon\).
    \[\begin{aligned}
        \delta(ab + abc + \varepsilon, a)
        &= \delta(a\cdot b, a) \cup \delta(a\cdot b\cdot c + \varepsilon, a)  &&\text{(E)} \\
        &= \delta(a\cdot b, a) \cup \delta(a\cdot b\cdot c, a) \cup \delta(\varepsilon, a)  &&\text{(E)} \\
        &= \{\varepsilon \cdot b\} \cup \delta(a\cdot b\cdot c, a) \cup \delta(\varepsilon, a)  &&\text{(F, v)} \\
        &= \{\varepsilon \cdot b\} \cup \{\varepsilon \cdot b \cdot c\} \cup \delta(\varepsilon, a)  &&\text{(F, v)} \\
        &= \{\varepsilon \cdot b\} \cup \{\varepsilon \cdot b \cdot c\} \cup \{\}  &&\text{(B)} \\
        &= \{\varepsilon \cdot b, \varepsilon \cdot b \cdot c\} 
    \end{aligned}\]
    Also notice that 
    \[\begin{aligned}
        a\cdot b + a \cdot b \cdot c + \varepsilon \in F 
        &\text{ if } a \cdot b \cdot c + \varepsilon \in F &&\text{(iv)} \\
        &\text{ if } \varepsilon \in F &&\text{(iv)} \\
        &\text{ and we know } \varepsilon \in F &&\text{(ii)} 
    \end{aligned}\]
    and therefore \(a\cdot b + a \cdot b \cdot c + \varepsilon \in F\).
    So, in the Antimirov automaton, you will see the following states and transitions:
    <div class="figure">
        <img src="../imgs/firstantimirov.svg" alt="Antimirov derivatives of ab+abc+epsilon are epsilon b, epsilon bc, and ab+abc+epsilon is accepting" />
        The first two derivatives of \(a\cdot b + a\cdot b \cdot c + \varepsilon\).
    </div>
</div>

<p>
    The significance of the Antimirov automaton is twofold: first, that it is yet again an automaton that witnesses languages "accepting themselves" (actually, the language semantics of a regular expression).
</p>

<div class="theorem">
    <b>(Antimirov Fixed-point)</b>
    Let \(r \in \mathit{RExp}\) be a regular expression. 
    Then the language semantics of \(r\) is equal to the language accepted by the state \(r\) in the Antimirov automaton.
    \[
        \mathcal L(r) = \mathcal L(\mathcal A_{Ant}, r)
    \]
</div>

</p>
    There are infinitely many states in \(\mathcal A_{Ant}\), because there are infinitely many regular expressions. 
    However! 
    The second point of significance for the Antimirov automaton is that the automaton generated by a regular expression in \(\mathcal A_{Ant}\), \(\langle r \rangle_{\mathcal A_{Ant}}\), is always finite. 
</p>

<div class="exercise">
    <b>(First Generated Antimirov Automaton)</b>
    Draw the state diagram of \(\langle a\cdot b + a \cdot b \cdot c + \varepsilon\rangle_{\mathcal A_{Ant}}\), which consists of all of the regular expressions reachable from \(a\cdot b + a \cdot b \cdot c + \varepsilon\) in the Antimirov automaton.
    Start with the state diagram computed in the Slightly More Complicated Derivatives example.
</div>

<div class="theorem">
    <b>(Regularity is Finite)</b>
    Every regular language is finitely recognizable. 
    That is,
    \[
        \mathsf{Reg} \subseteq \mathsf{Fin}
    \]
</div>




<!-- END OF BODY -->
    <div style="height: 50px;border-top: 1px solid rgb(131, 131, 131);margin-top: 50px; padding: 20px; text-align: right;">
        <a href=""><span class="link">Top</span></a>
    </div>
</div>
</div>
</body>


</html>