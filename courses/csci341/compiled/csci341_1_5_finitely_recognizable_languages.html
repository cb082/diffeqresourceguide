<!-- THIS IS A COMPILED FILE 
 Compiled on 2025-07-28 -->



































































































<html>

<head>
	
	<meta charset="UTF-8">
	<meta name="author" content="Todd Schmid">
	
	<!-- Renders latex formulas -->
	<script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
	<script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    
	<!-- Renders tikz figures mid page -->
    <link rel="stylesheet" type="text/css" href="https://tikzjax.com/v1/fonts.css">
    <script src="https://tikzjax.com/v1/tikzjax.js"></script>
	
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	
	<link rel="stylesheet" href="../../../styles.css" />
	<link rel="stylesheet" href="../../course_styles.css" />
	<link rel="icon" href="../../../squidab.png" />
	
	<!-- * Customize for each course * -->
	<title>CSCI 341 Theory of Computation</title>
	<meta name="description" content="Course pages for CSCI 341.">
	<meta name="keywords" content="bucknell,theory,computer,science,schmid,csci341">
	<!-- ***************************** -->
</head>

<body>

<div id="content">

<!-- Header Section -->
<div id="course_head" style="text-align: left;">
	<h1 style="margin-bottom: 0; text-align: left;">CSCI 341 Theory of Computation</h1>
	<i>Fall 2025, with <a href="../../../teaching.html">Schmid</a></i>
	<div id="links">
		<!-- * Customize for each course * -->
		<a href="csci341_syllabus.html"><span class="link">Syllabus</span></a>
		<a href="csci341_notes.html"><span class="link">Notes</span></a>
		<a href="csci341_resources.html"><span class="link">Resources</span></a>

		<!-- Make sure to update with correct gradescope link-->
		<a href= 
			"http://www.gradescope.com" 
			target="_blank"><span class="link">Gradescope</span></a>
		<!-- ***************************** -->
	</div>
</div>



<div id="stuff">


<!-- BEGINNING OF BODY -->
<h1>Finitely Recognizable Languages</h1>

<p>
    Brzozowski's Fixed Point Theorem tells us that every language is accepted by <i>some</i> state of <i>some</i> automaton.
    In particular, the language \(L\) is accepted by the state \(L\) in the Brzozowski automaton \(\mathcal A_{Brz}\).
    One issue with this theorem is that it doesn't tell you <i>how big</i> that automaton might be. 
    In fact, it could be infinite for all we know!
</p>

<p>
    Thankfully, the whole Brzozowski automaton is not needed, only the part that corresponds to \(L\). 
</p>

<h2>Reachability and Local Finiteness</h2>
<p>
    The Brzozowski automaton was most definitely an infinite automaton.
    But something very special happened in the <a href="csci341_1_4_finite_and_infinite_automata.html#unravelling" target="_blank">Unravelling a Language</a> problem:
    the states reachable from that language were finite in number.
</p>

<div class="definition" id="generated">
    <b>(Generated, Locally Finite)</b>
    Let \(\mathcal A = (Q, A, \delta, F)\) be an automaton and let \(x \in Q\) be a state. 
    The <i>automaton generated by \(x\)</i> is the automaton \(\langle x \rangle_{\mathcal A} = (Q_x, A, \delta_x, F_x)\) defined by 
    \[\begin{aligned}
        Q_x &= \bigcup_{w \in A^*} \delta(x, w) \\
        \delta_x &= \delta \cap (Q_x \times Q_x) \\
        F_x &= F \cap Q_x \\
    \end{aligned}\]
    The state \(x \in Q\) of \(\mathcal A\) is called <i>locally finite</i> if \(Q_x\) is finite, i.e., \(\langle x \rangle_{\mathcal A}\) is a finite automaton. 
    The automaton \(\mathcal A\) is called <i>locally finite</i> if every state \(x \in Q\) is locally finite. 
</div>

<p>
    Above, the notation \(\bigcup_{w \in A^*} \delta(x, w)\) is shorthand notation for the set 
    \[
        \bigcup_{w \in A^*} \delta(x, w) = \{y \mid \text{there is a word \(w \in A^*\) such that \(y \in \delta(x, w)\)}\}
    \]
    The definition of \(\delta_x\) just says that it has all the same transitions as \(\delta\) but restricted to \(Q_x\).
    Note that \(\langle x \rangle_{\mathcal A}\) has the same alphabet as \(\mathcal A\).
</p>

<div class="example">
    <b>(A=B)</b>
    Recall that in the Brzozowski automaton \(\mathcal A_{Brz}\), the states are languages, the transitions are given by derivatives, \(L \xrightarrow{a} a^{-1}L\), and the accepting states are the languages \(L\subseteq A^*\) that contain the empty word \(\varepsilon \in L\).
    The following language is a classic example of a language that generates an infinite subautomaton of the Brzozowski automaton \(\mathcal A_{Brz}\):
    \[
        L_{a=b} = \big\{ a^nb^n \mid n \in \mathbb N\big\}
    \]
    After \(k\) \(a\)-derivatives, the language becomes
    \[
        a^{-k}L_{a=b} = \big\{ a^{n-k}b^n \mid n \in \mathbb N, n \ge k\big\}
    \] 
    If \(k \lneq k'\), then \(a^{-k}L_{a=b} \neq a^{-k'}L_{a=b}\), so there is a distinct state in \(\langle L_{a=b}\rangle_{\mathcal A_{Brz}}\) for each \(k \in \mathbb N\).
    This means infinitely many!
</div>

<div class="exercise">
    <b>(Distinct Derivatives of A=B)</b>
    Show that \(a^{-1}L_{a=b} \neq a^{-2}L_{a=b}\) by finding a word in one of the languages that is not in the other. 
    How would you generalize this to a proof that if \(k \lneq k'\), then \(a^{-k}L_{a=b} \neq a^{-k'}L_{a=b}\)?
</div>

<p>
    It turns out that \(L_{a=b}\) is not accepted by <i>any</i> state in <i>any</i> finite automaton. 
    We don't quite have the tools to prove this yet, though.
    We will see those later when we talk about the Pumping Lemma for finite automata.
</p>

<div class="exercise">
    <b>(Reachable = Generated)</b>
    Let \(\mathcal A = (Q, A, \delta, F)\) be an automaton and let \(x \in Q\) be a state. 
    Convince yourself of the following three statements: 
    <ol>
        <li>
            \(Q_x = \{ y \in Q \mid \text{there is a path \(x \xrightarrow{a_1} x_1 \xrightarrow{a_2} \cdots \xrightarrow{a_n} y\) in \(\mathcal A\)} \}\)
        </li>
        <li>
            for any \(y,z \in Q_x\), \(y \xrightarrow{a} z\) in \(\mathcal A\) if and only if \(y \xrightarrow{a} z\) in \(\langle x \rangle_{\mathcal A}\)
        </li>
        <li>
            for any \(y \in Q_x\), \(y\in F\) if and only if \(y \in F_x\)
        </li>
    </ol>
    Explain why this implies that \(\mathcal L(\mathcal A, x) = \mathcal L(\langle x \rangle_{\mathcal A}, x)\).
    <div class="hint">
        Remember that to prove a statement like "\(P\) if and only if \(Q\)", you need to write two separate proofs: you need to prove (1) that "if \(P\), then \(Q\)", and (2) that "if \(Q\), then \(P\)".
    </div>
</div>

<div class="exercise">
    <b>(Reverse Naturals Again)</b>
    Remember that the Reverse Naturals automaton was defined by \(Q = \mathbb N\), \(A = \{l\}\), and \(n + 1 \xrightarrow{l} n\) for all \(n \in Q\).
    Is the Reverse Naturals automaton locally finite?
    What if we replace \(l\) with the the input letter \(s\) that <i>adds one</i> instead of subtracts: \(n \xrightarrow{s} n + 1\)?
</div>

<h2>Finitely Recognizable Languages</h2>

<p>
    So we've seen that it's possible for a language to generate an infinite automaton. 
    Which ones are the languages that generate finite automata?
    Obviously, we can't store an infinite automaton in a computer, let alone run one. 
    <i>Which languages can be accepted by a state in a finite automaton?</i>
    In fact, <i>which languages can be accepted by a state in a deterministic, or total deterministic finite automaton?</i>
    Questions like this lead us to considering a whole range of different families of languages in this course.
</p>

<div class="definition" id="finitelyrecognizable">
    <b>(Language Families, Finitely Recognizable)</b>
    A <i>family of languages</i> is a set of languages \(\mathsf{Fam} \subseteq 2^{A^*}\) over a fixed alphabet of input letters \(A\).
    We are concerned with the following families of languages:
    <ul>
        <li>
            A language \(L\subseteq A^*\) is <i>finitely recognizable</i> if there is a finite automaton \(\mathcal A = (Q, A, \delta, F)\) (i.e., \(Q\) is finite) and a state \(x \in Q\) such that \(L = \mathcal L(\mathcal A, x)\).
            The family of finitely recognizable languages is
            \[
                \mathsf{Fin} = \big\{ L \subseteq A^* \mid \text{\(L\) is finitely recognizable} \big\}
            \]
        </li>
        <li>
            A language \(L\subseteq A^*\) is <i>deterministic finitely recognizable</i> if there is a deterministic finite automaton \(\mathcal A = (Q, A, \delta, F)\) and a state \(x \in Q\) such that \(L = \mathcal L(\mathcal A, x)\).
            The family of deterministic finitely recognizable languages is
            \[
                \mathsf{DFin} = \big\{ L \subseteq A^* \mid \text{\(L\) is deterministic finitely recognizable} \big\}
            \]
        </li>
        <li>
            A language \(L\subseteq A^*\) is <i>total deterministic finitely recognizable</i> if there is a total deterministic finite automaton \(\mathcal A = (Q, A, \delta, F)\) and a state \(x \in Q\) such that \(L = \mathcal L(\mathcal A, x)\).
            The family of total deterministic finitely recognizable languages is
            \[
                \mathsf{TDFin} = \big\{ L \subseteq A^* \mid \text{\(L\) is total deterministic finitely recognizable} \big\}
            \]
        </li>
    </ul>
</div>

<p>
    Something you should notice immediately: every total deterministic automaton is a deterministic automaton, and every deterministic automaton is an automaton. 
    This means implies that 
    \[
        \mathsf{TDFin} \subseteq \mathsf{DFin} \subseteq \mathsf{Fin}
    \]
    right off the bat!
    But what about the reverse inclusions?
</p>

<div class="exercise">
    <b>(CJ's Pergatory)</b>
    For each of the deterministic partial automata below, find a total deterministic automaton with a state that accepts the same language as \(x\).
    In each example, the input alphabet is \(A = \{a, b, c\}\).
    <div class="figure">
        (1)<img src="../imgs/CJPerg1.svg" />
        (2)<img src="../imgs/CJPerg2.svg" />
        (3)<img src="../imgs/CJPerg3.svg" />
        (4)<img src="../imgs/CJPerg4.svg" />
    </div>
    <div class="hint">
        You only ever need to add one state!
    </div>
</div>

<div class="problem">
    <b>(Total vs Partial)</b>
    Prove that \(\mathsf{DFin} = \mathsf{TDFin}\) by describing how to turn a deterministic automaton into a total deterministic automaton without changing the languages accepted by the states.
    <div class="hint">
        What did you do in the CJ's Pergatory exercise every time?
    </div>
</div>

<p>
    In the next lecture, we are going to see that in fact, all three families of languages are equal.
</p>





<!-- END OF BODY -->
    <div style="height: 50px;border-top: 1px solid rgb(131, 131, 131);margin-top: 50px; padding: 20px; text-align: right;">
        <a href=""><span class="link">Top</span></a>
    </div>
</div>
</div>
</body>


</html>