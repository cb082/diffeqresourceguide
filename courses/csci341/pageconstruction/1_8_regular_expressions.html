<h1>Regular Expressions and Languages</h1>

<p>
    Before, we mentioned that automata are like machines, and states are like programs. 
    What we are missing so far in this course is a <i>coding language</i> for these programs.
    That's what we are about to talk about for the next few lectures, <i>a coding language for states in automata</i>.
    Most of you have seen <i>regular expressions</i> at his point in your career. 
    The regular expressions that theoretical computer scientists study are quite a bit different: they are like the regular expressions you know, except they can't do anything like count instances of a string or whatnot. 
</p>

<p>
    It turns out that if you remove all the bells and whistles from the regular expressions you know and love, you get coding language that is perfectly suited to programming states of finite automata.
    Today we're going to step away from finite automata for a moment and just get familiar with regular expressions on their own.
</p>

<h2>Regular Expression Syntax</h2>

<p>
    The set of regular expressions has a recursive definition that tells us <i>how they can be formed</i>. 
    This involves a bunch of rules for how to form new regular expressions from old ones. 
    Formally, the definition looks like this:
</p>

<div class="definition" id="RegEx">
    <b>(Regular Expressions)</b>
    Let \(A\) be an alphabet of input symbols.
    The <i>set of regular expressions over \(A\)</i> is written \(\mathit{RExp}\) and defines by the following formation rules:
    <ul>
        <li>The symbol \(\varepsilon\) is a regular expression, \(\varepsilon \in \mathit{RExp}\).</li>
        <li>The symbol \(\emptyset\) is a regular expression, \(\emptyset \in \mathit{RExp}\).</li>
        <li>For any input letter \(a \in A\), the symbol \(a\) is a regular expression, \(a \in \mathit{RExp}\).</li>
    </ul>
    The next few formation rules are the <i>recursive</i> ones: each rule builds a new regular expression from old ones.
    <ul>
        <li>If \(r_1, r_2 \in \mathit{RExp}\) are regular expressions, then so is \((r_1 + r_2) \in \mathit{RExp}\).</li>
        <li>If \(r_1, r_2 \in \mathit{RExp}\) are regular expressions, then so is \((r_1 \cdot r_2) \in \mathit{RExp}\).</li>
        <li>If \(r \in \mathit{RExp}\) is a regular expression, then so is \((r)^* \in \mathit{RExp}\).</li>
    </ul>
    The elements of the set \(\mathit{RExp}\) are called <i>regular expressions</i>.
</div>

<div class="example">
    <b>(Some Regular Expressions)</b>
    The string of symbols \( ((((a + \emptyset))^* \cdot \varepsilon) + b)\) is a regular expression (over the alphabet \(A = \{a, b\}\)). 
    You can form this expression as follows:
    <ol>
        <li>\(a\), \(\emptyset\), \(\varepsilon\), and \(b\) are regular expressions.</li>
        <li>Since \(a\) and \(\emptyset\) are regular expressions, \((a + \emptyset)\) is a regular expression.</li>
        <li>Since \((a + \emptyset)\) is a regular expression, \(((a + \emptyset))^*\) is a regular expression.</li>
        <li>Since \(((a + \emptyset))^*\) and \(\varepsilon\) are a regular expressions, \((((a + \emptyset))^* \cdot \varepsilon)\) is a regular expression.</li>
        <li>Since \((((a + \emptyset))^* \cdot \varepsilon)\) and \(b\) are a regular expressions, \(((((a + \emptyset))^* \cdot \varepsilon) + b)\) is a regular expression.</li>
    </ol>
</div>