<h2>Table of Contents</h2>

<div id="contents">
	<ul style="list-style-type: none;">
		<li><a href="csci341_1_introduction.html">Introduction to Computational Problems</a></li>
		<li><a href="csci341_1_introduction.html"><b>Part 1.</b> Memoryless State Machines</a>
			<ol>
				<li><a href="csci341_1_introduction.html">Sokoban games, state diagrams, and winning</a></li>
				<!--
					- Sokoban Games
						• Legal moves as machine input
						• Winning
					- State diagrams and transition tables
						• Visual representation of state machines
						• Legal moves are functions: transition tables
						• Winning states
						• Pergatory
					- Lamps, unidirectional mazes, vending machines, combination locks, and legal identifiers in Python
				-->
				<li><a href="csci341_1_introduction.html">Describing the set of winning sequences</a>
				<!--
					- Words from an alphabet
					- The empty set, the empty word
					- Languages from an alphabet
					- Describing the space of accepted moves 
						• set comprehension
						• union, intersection
						• concatenation
						• the Kleene star 	
				-->
				<li><a href="csci341_1_introduction.html">Deterministic automata</a>
				<!--
					- The power of abstraction
					- The definition of deterministic automaton (DA)
						• X = State space
						• A = Alphabet of "legal moves" or "actions"
						• \delta : A x X -> X = Transition function
						• \alpha : X -> 2 = Accept/reject function
					- Drawing DAs
						• Circles, double cicles, arrows, and labels
						• Transition tables
					- Basic examples:
						• The empty automaton
						• One-state and two-state automata
					- Intuitive notion of word acceptance	
					- Using a sink to simulate borkedness (pergatory)
				-->
				</li>
				<li><a href="csci341_1_introduction.html">Finite and infinite deterministic automata</a>
				<!-- 
					- Examples of Deterministic Finite Automata (DFAs)
						• Example. The integers modulo 3, Z/3Z = {0, 1, 2}, with alphabet A = {(x + 1) % 3, (x + 2) % 3}
						• Examples. Mazes, parity relations, and sokoban games
					- Infinite examples of deterministic automata
						• Example. The integers Z, with the shift alphabet A = {-1, +1} and even numbers accepting
							>> Language accepted by 0?
						• Example. The deterministic automaton of all languages from an alphabet
					- Languages as states
						• The Brzozowski derivative
						• Acceptance and the empty word property
						• Languages accept themselves (so every language is accepted by some state in some deterministic automaton!)
				-->					
				</li>
				<li><a href="csci341_1_introduction.html">Introducing Nondeterminism</a>
				<!--
					- A function is a kind of relation
					- Nondeterminism = moving from functions to relations
						• Relations as functions X -> P(X)
					- Three interpretations:
						• What words *could* an unpredictable machine accept?	
						• A working machine with different but indistinguishable labels
						• Teamwork (or cloning yourself)
					- Nondeterministic Finite Autommata
						• X = state space
						• A = alphabet
						• \delta : A x X -> P(X)
						• \alpha : X -> 2
				-->
				<li><a href="csci341_1_introduction.html">DFAs and NFAs</a>
				<!-- 
					- Transforming a DFA into an NFA
					- NFAs are smaller in general
					- Overturning power with determinization
				-->
				<li><a href="csci341_1_introduction.html">Silent transitions &#129323;</a>
				<!--
					- Skiping a beat
					- Interpretation: there are unobservable transitions
					- Killing epsilons with a dagger (the dagger construction)
				-->
			</ol>
		</li>
		<li><a href="csci341_1_introduction.html"><b>Part 2.</b> Machines with Memory</a></li>
			<ol>
				<li><a href="csci341_1_introduction.html">Solving Problems with Stacks</a></li>
				<!--
					- Adding up to 0
					- Palindromes
					- 
				-->
				<li><a href="csci341_1_introduction.html">Pushdown Finite Automata</a></li>
				<!--
					- 
				-->
			</ol>
		<li><a href="csci341_1_introduction.html"><b>Part 3.</b> Formal Language Theory</a></li>
		<li><a href="csci341_1_introduction.html"><b>Part 4.</b> (Un)Decidability</a></li>
		<li><a href="csci341_1_introduction.html"><b>Part 5.</b> Complexity</a></li>
		<li><a href="csci341_2_decision_problems.html">Section Decision Problems</a></li>
		<li><a href="csci341_3_regular_languages.html">Regular Languages</a></li>
		<li><a href="csci341_4_automata.html">Automata</a></li>
		<li><a href="csci341_5_kleene_theorem.html">Kleene's Theorem</a></li>
		<li><a href="csci341_6_irregular_languages.html">Irregular Languages</a></li>
		<li><a href="csci341_7_context_free_languages.html">Context-Free Languages</a></li>
		<li><a href="csci341_8_pushdown_automata.html">Nondeterministic Pushdown Automata</a></li>
		<li><a href="csci341_9_computability.html">Computability</a></li>
		<li><a href="csci341_10_turing_machines.html">Turing Machines</a></li>
		<li><a href="csci341_11_undecidability.html">Undecidability</a></li>
		<li><a href="csci341_12_complexity.html">Complexity</a></li>
	</ul>
</div>