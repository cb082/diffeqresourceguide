<h2>Table of Contents</h2>

<div id="contents">
	<ul style="list-style-type: none;">
		<li><a href="csci341_0_what_is_computation.html">What is <i>computation</i>?</a></li>
		<li><b>Part 1.</b> Automata and Languages
			<ol>
				<li><a href="csci341_1_0_games_and_state_diagrams.html">Puzzle games, solutions, and state diagrams</a></li>

				<li><a href="csci341_1_1_automata.html">Automata</a></li>
				<!--
				- Automata, Transition Tables, Accepting states
					• Transition tables
				- Drawing DAs
					• Circles, double cicles, arrows, and labels
				- Basic examples:
					• The empty automaton
					• Parity recognition and modular arithmetic
				- Deterministic transition systems
					• X = State space
					• A = Alphabet of "legal moves" or "actions"
					• \delta : A x X -> X = Transition function
				- Deterministic, total, partial, and nondeterminsitic automata
					• \delta as a function
				-->

				<li><a href="csci341_1_2_reading_words.html">Reading words</a></li>
				<!-- 				
				- Words from an alphabet
				- The empty word
				- Words read into an automaton
				- Induction on Words
				-->
				
				<li><a href="csci341_1_3_language_acceptance.html">Languages and acceptance</a></li>
				<!--
				- Accepting states as "winning configurations"
				- Accepting words
				- States as programs that accept/reject words
				-->

				<li><a href="csci341_1_4_finite_and_infinite_automata.html">Finite and infinite deterministic automata</a></li>
				<!-- 
				- Finiteness of special: not every automaton is finite
				- Examples of Infinite Automata (DFAs)
					• Example. The reverse naturals
					• Example. Grid world
				- Brzozowski's automaton: The deterministic automaton of all languages from an alphabet
					• Languages as states
						* The Brzozowski derivative
						* Acceptance and the empty word property
						* The Brzozowski automaton is total and deterministic
						* Languages accept themselves, so every language is accepted by some state in some total deterministic automaton
				- Reachability and the subautomaton generated by a state
				- Local finiteness
					• Of the reverse naturals, for example
				- Some languages generate finite subautomata of Brzowski's automaton. Which ones are they?
				-->	

				<li><a href="csci341_1_5_finitely_recognizable_languages.html">Finitely Recognizable Languages</a></li>
				<!--
				- Families of languages
					• Some families contain each other
					• If one family F is strictly contained in F', then F' is "more expressive than F"
					• Example: the finite languages form a family of languages
				- Three families that jump out to us:
					• Finite Acceptor Languages (accepted by some state in some automaton)
					• Deterministic Finite Acceptor Languages (accepted by a deterministic automaton)
					• Total Deterministic Finite Acceptor Languages (accepted by a total deterministic automaton)
					• Naive comparisons between the three
				- Determinization and the collapse of the Finite Acceptor Language hierarchy
				-->

				<!-- 
				<li><a href="">Combining Automata I: Meets, Joins, and Complementation</a></li>
					- Warming up: disjoint union
					- Complementation
					- The product construction for deterministic transition systems
						• product-meet = intersection
						• product-join = union
					- An intuitive construction: Glueing? (feeds into nondeterminism!)
				-->					
				
				<!--
				<li><a href="">Silent transitions &#129323;</a></li>
					- Skiping a beat: there are unobservable transitions
					- Nondeterministic Finite Automata with silent transitions (NFA_{\e})
						• X = state space
						• A = alphabet
						• \delta : (A u \epsilon) x X -> P(X)
						• \alpha : X -> 2
					- Every NFA is an NFA_{\e}
					- Language accepted by a state in an NFA_{\e}
				-->

				<!--
				<li><a href="">Killing epsilons with a dagger</a></li>
					- The dagger construction
					- Every NFA_{\e} language is an NFA language
					- DFA languages = NFA languages = NFA_{\e} languages
						• Call all of these *finite acceptor languages*, or FA languages
				-->

				<!--
				<li><a href="">Combining Automata II: sequential composition and iteration</a></li>
					- The tent construction
						• Union
					- The suspention construction (placing a state on either end)
					- Using silent transitions to connect accepting states to starting states
						• Sequential Composition
						• Iteration			
				-->

				<!--
				<li><a href="">The Pumping Lemma</a></li>
					- Weakest version
					- A little less weak
					- Strongest version
					- Examples of non-DFA languages
						• a^nb^n
						• Palindromes
						• Adding up to 0
						• Balanced brackets
				-->
				
			</ol>
		</li> <!-- ****** End of Part 1 -->



		<li><b>Part 2.</b> Computability
		<ol>

			<!--
				<li><a href="csci341_1_introduction.html">Regular Expressions</a></li>
					- Recursive definition of regular expressions
					- Language semantics of regular expressions: regular languages
					- Language equivalence of regular expressions
						• Some useful (basic) identities
						• The empty word property and Arden's rule
				-->

				<!--
				<li><a href="csci341_1_introduction.html">Pick your weapon: Antimirov derivatives or Thompson's construction</a></li>
					- Every regular expression denotes an NFA
						• Antimirov's derivative construction: using regular expressions as states
							>> Ant(r) is finite, with O(n) states
							>> L(Ant(r), r) = L(r)
						• Thompson's construction: recursively building an NFA_{\e}
							>> Tho(r) is finite, also O(n) states
							>> L(Tho(r), r) = L(r)
					- Corollary: Every regular language is a FA language
				-->

				<!--
				<li><a href="csci341_1_introduction.html">Kleene's Theorem, or Gaussian Elimination for NFAs</a></li>
					- Left-affine systems of equations over an alphabet A
						• Guardedness
					- A language-based solution to a left-affine system
					- Guarded left-affine systems have unique solutions
						• Gaussian Elimination for left-affine systems
						• Repeated use of Arden's rule and the "useful identities" from before
					- Language acceptance and NFAs as guarded left-affine systems
					- Corollary: every FA language is a regular language
					- Kleene's Theorem: FA languages = Regular languages
				-->

				<!--
				<li><a href="csci341_1_introduction.html">Beyond Regularity: Non-affine systems</a></li>
					- Going from left-affine systems of equations to "polynomial" systems of equations goes beyond regular/FA languages
						• a^nb^n
						• Palindromes
						• Adding up to 0
						• Balanced brackets
					- Solving polynomial systems by way of derivations
				-->

				<!--
				<li><a href="csci341_1_introduction.html">Context-free Grammars</a></li>
					- definition of a context-free grammar (CFG)
						• N = nonterminal variables
						• A = terminal constants
						• \delta : N -> (A u N)* = derivation rules
					- Complete derivations
					- Context-free languages
				-->

				<!--
				<li><a href="csci341_1_introduction.html">Designing Context-free Grammars</a></li>
					
				-->
				
				<!--
				<li><a href="csci341_1_introduction.html">The Chomsky Hierarchy</a></li>
					- 
				-->

			</ol>
		</li> <!-- ****** End of Part 3 -->


		<li><b>Part 3.</b> Machines with Memory
			<ol>
				<!--
				<li><a href="csci341_1_introduction.html">Solving Problems with Stacks</a></li>
					- Algorithms that use a stack to decide...
						• a^nb^n
						• Palindromes
						• Adding up to 0
						• Balanced brackets
				-->

				<!--
				<li><a href="csci341_1_introduction.html">Push-Down Automata</a></li>
					- PDA = NFA_{\e} + Stack
						• X = state space
						• A = input alphabet
						• S = stack alphabet
						• \delta : ({\e} u A) x X -> P(({\e} u ↿S) x ({\e} u ⇃S) x X)
						• Balanced brackets
					- PDA languages
					- PDAs are infinite NFA_{\e}s
					- PDAs =/= DFA + Stack
				-->

				<!--
				<li><a href="csci341_1_introduction.html">Designing Push-Down Automata</a></li>
					- 
				-->

				<!--
				<li><a href="csci341_1_introduction.html">CFGs from PDAs</a></li>
					- Every Context-free language is PDA
				-->

				<!--
				<li><a href="csci341_1_introduction.html">PDAs from CFGs</a></li>
					- Every PDA language is Context-free
					- PDA Languages = Context-free Languages
				-->

				<!--
				<li><a href="csci341_1_introduction.html">Beyond the Stack: Tapes</a></li>
					- The tape head
					- Reading, writing, and moving
					- Programming a tape head
					- Solving problems with a tape head
				-->

				<!--
				<li><a href="csci341_1_introduction.html">Turing Machines</a></li>
					- Input string goes on a tape
					- TM = DFA + Tape
						• X = state space
						• A = input alphabet
						• T = tape alphabet
						• \delta : ({\e} u A) x X -> ({\e, >, <} u {∨} x T) x (2 u X)
					- The languages accepted and rejected by a TM
					- Decidable languages
				-->

				<!--
				<li><a href="csci341_1_introduction.html">Designing Turing Machines</a></li>
					- 2s complement
					- reversing text
					- perfect squares
					- Simulating a DFA
					- Simulating a PDA
				-->

				<!--
				<li><a href="csci341_1_introduction.html">Recognizable and co-Recognizable Languages</a></li>
					- Halting states
					- Enumerable languages
				-->

				<!--
				<li><a href="csci341_1_introduction.html">Variants of Turing Machines</a></li>
					- TM equivalents:
						• Multi-tape TMs
						• Nondeterministic TMs
						• One-sided TMs
						• An assembly-like language for tape heads
						• WHILE programs and flow charts
					- The Church-Turing Thesis
						• Turing-hard = can simulate a TM
						• Turing-complete = TM can simulate you
					    • Thesis: Turing-hard = Turing-complete
						• A mathematical definition of the word "algorithm"
				-->

			</ol>
		</li><!-- ****** End of Part 3 -->


		<li><b>Part 4.</b> (Un)Decidability
		<ol>
			<!--
				<li><a href="csci341_1_introduction.html">Encodings and Universal Turing Machines</a></li>
					- Turing machines as encodable objects
					- Running a TM within a TM
				-->

				<!--
				<li><a href="csci341_1_introduction.html">The Halting Problem</a></li>
					- Turing's diagonalization argument
					- Recognizable but not co-recognizable
				-->

				<!--
				<li><a href="csci341_1_introduction.html">Reductions</a></li>
					- Language inhabitation
					- Language equivalence
					- A language neither recognizable or co-recognizable
				-->

				<!--
				<li><a href="csci341_1_introduction.html">Post's correspondence theorem</a></li>
					- 
				-->

			</ol>
		</li> <!-- ****** End of Part 4 -->

		<li><a href="">Concluding Remarks and Open Problems</a></li>

	</ul> <!-- ***** End of Table of Contents -->
</div>