<h1>Parse Trees</h1>

<p>
    Last time, we saw how to use context-free grammars to derive least solutions to polynomial systems of equations.
    One of the exercises we did was a derivation of the grammatical correctness of a few different english sentences.
    This was the grammar:
    \[\begin{aligned}
        S &\to N_P V_P N_P \\
        N_P &\to BAN \mid BN \\
        A &\to \texttt{nice} \mid \texttt{mean} \\
        B &\to \texttt{the} \mid \texttt{a} \\
        N &\to \texttt{boy} \mid \texttt{girl} \mid \texttt{dog} \\
        V_P &\to \texttt{likes} \mid \texttt{hates} 
    \end{aligned}\]
    In this context-free grammar, the variables all <i>mean something</i>: \(S\) stands for "sentence", \(N_P\) stands for "noun phrase", \(A\) stands for "adjective", \(B\) for "article", \(N\) for "noun", and \(V_P\) for "verb".
    This makes the derivations a bit opaque, and not really how we build sentences in our heads.
    The reason they are opaque is that the don't build the sentence in a way that is informed by the <i>semantics</i> of the sentence (what the sentence means).
    This becomes a little clearer when a notion of <i>evaluation</i> is introduced, like in arithmetic.
</p>

<div class="example">
    <b>(Arithmetic Expressions)</b>
    In the following grammar, the variable \(E\) derives the language \(\mathit{ArExp}\) of <i>arithmetic expressions</i>.
    \[\begin{aligned}
        E &\to 
            N
            \mid (E + E)
            \mid (E \times E)
            \mid (E - E)
            \mid (E / E) \\
        N &\to 0 \mid 1 \mid 2 \mid 3 \mid 4 \mid 5 \mid 6 \mid 7 \mid 8 \mid 9 \mid NN
    \end{aligned}\]
    Let's call this grammar \(\mathcal G_{\mathbb N} = (X, A, R)\).
    Above, \[
        A = \big\{ (, ), +, \times, -, /, 0,1,2,3,4,5,6,7,8,9 \big\}
    \]
    because these are all the symbols we needed to form the monomial expressions above.
    For a first example of an arithmetic expression, let's derive:
    \[\begin{aligned}
        E 
        &\Rightarrow (E + E) \\
        &\Rightarrow (N + E) \\
        &\Rightarrow (N + (E \times E)) \\
        &\Rightarrow (N + (E \times N)) \\
        &\Rightarrow (N + (N \times N)) \\
        &\Rightarrow (NN + (N \times N)) \\
        &\Rightarrow (9N + (N \times N)) \\
        &\Rightarrow (90 + (N \times N)) \\
        &\Rightarrow (90 + (NN \times N)) \\
        &\Rightarrow (90 + (1N \times N)) \\
        &\Rightarrow (90 + (10 \times N)) \\
        &\Rightarrow (90 + (10 \times 2)) 
    \end{aligned}\]
    This tells us that \((90 + (10 \times 2)) \in \mathit{ArExp}\).
    But of course, this derivation could have happened in many different ways; we could have changed the first \(N\) to an \(NN\) much earlier, or changed the second \(E\) in the first step to an \((E \times E)\) right away. 
    The following diagram condenses all of the different ways this expression could be formed into a single tree:
    <div class="figure">
        <img src="../imgs/syntax_tree_arithmetic.svg" alt="A parse tree for (90 + (10 \times 2))" />
        A parse tree for \((90 + (10 \times 2))\).
    </div>
    This is called a <i>parse tree</i> for the arithmetic expression \((90 + (10 \times 2))\).
    This tree might seem opaque at first, but if you read all of the <i>leaves</i> of the tree left-to-right, then you recover the expression that formed the tree to begin with.
    <div class="figure">
        <img src="../imgs/syntax_tree_arithmetic_complete.svg" alt="How to read the parse tree for \((90 + (10 \times 2))\)." />
        How to read the parse tree for \((90 + (10 \times 2))\).
    </div>
</div>